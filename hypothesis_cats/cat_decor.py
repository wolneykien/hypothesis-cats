# This file is a part of the Hypothesis-Cats Python package.
#
# Copyright (C) 2022  Paul Wolneykien <manowar@altlinux.org>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301, USA.

"""
Hypothesis-Cats allows you to classify values generated by a
`Hypothesis <https://hypothesis.readthedocs.io/en/latest/>`_
strategy. This module defines decorator functions that help to supply
categorized data to test functions in form of strategies and examples.
"""

from typing import Union, Any, Callable, Mapping, Sequence, Dict, \
    Optional

from hypothesis import given, example
from hypothesis.strategies import SearchStrategy

from .cat_strategies import cat, cats, cats_desc, subdivide
from .cat_checks import parseCats, CatChecker, ExCat, CatLayout

CATS_LAYOUT_ARG = '_layout_'
CATS_DESC_ARG = '_desc_'
CATS_EXAMPLE_ATTR = '_hypothesis_cats_example'

def copy_desc(in_desc: Mapping[str, Union[SearchStrategy, bool, Mapping[str, Union[SearchStrategy, Mapping[str, Any]]]]], out_desc: Dict[str, Union[SearchStrategy, bool, Dict[str, Union[SearchStrategy, Mapping[str, Any]]]]]):
    """
    A utility function used to pre-process arguments passed to
    :func:`given_divided`.

    :param in_desc: An input mapping.

    :param out_desc: A dictionary to copy the values to.
    """
    for cls in in_desc:
        cls_val = in_desc[cls]
        if isinstance(cls_val, SearchStrategy):
            out_desc[cls] = cls_val
        elif isinstance(cls_val, bool):
            out_desc[cls] = cls_val
        else:
            cls_dict = {}
            for ctg_name in cls_val:
                cls_dict[ctg_name] = cls_val[ctg_name]
            out_desc[cls] = cls_dict

    return out_desc

def given_divided(*desc_list: Mapping[str, Union[SearchStrategy, bool, Mapping[str, Union[SearchStrategy, Mapping[str, Any]]]]], **desc_dict: Union[SearchStrategy, bool, Mapping[str, Union[SearchStrategy, Mapping[str, Any]]]]) -> Callable[[Callable], Callable]:
    """
    A decorator combining @:func:`given` with
    :func:`.cat_strategies.subdivided`. For each data argument it's
    possible to define a single strategy value or a to divide it into a
    number of categories with different strategies and, if necessary,
    exception expectations. For example:

    .. code-block:: python

       @given_divided(
           name={
               'empty': {
                   'raises': {
                       'err': TypeError,
                       'pattern': '^Name'
                   },
                   'values': text(max_size=0)
               },
               'non-empty': text(min_size=1)
           },
           role={
               'empty': text(max_size=0),
               'non-empty': text(min_size=1)
           },
           age={
               'non-positive': {
                   'raises': {
                       'err': ValueError,
                       'pattern': '^Age',
                   },
                   'values': integers(max_value=0)
               },
               'positive': integers(min_value=1)
           }
       )
       def test_user(name, role, age, _layout_, _desc_):
           with CatChecker(_layout_, _desc_):
               u = User(name, role, age)

    The supplied description is processed and automatically supplied
    to the wrapped test function under name ``_desc_``. The current
    category layout, in turn, is passed as ``_layout_``. If for some
    reason you do not want that â€” pass ``False`` under the
    corresponding name to :func:`given_divided`.
    """
    desc: Dict[str, Union[SearchStrategy, bool, Dict[str, Union[SearchStrategy, Mapping[str, Any]]]]]  = {}
    for d in desc_list:
        copy_desc(d, desc)
    copy_desc(desc_dict, desc)

    data_layout: Dict[str, SearchStrategy[Any]] = {}
    ctg_defs: Dict[str, Dict[str, ExCat]]  = {}

    for cls in desc:
        cls_layout = []
        cls_val = desc[cls]
        if isinstance(cls_val, SearchStrategy):
            data_layout[cls] = cls_val
        elif isinstance(cls_val, bool):
            pass
        else:
            ctg_defs[cls] = {}
            for ctg_name in cls_val:
                ctg_desc = cls_val[ctg_name]
                if isinstance(ctg_desc, SearchStrategy):
                    ctg_strategy = ctg_desc
                    ctg_obj = ExCat(name=ctg_name)
                else:
                    if 'values' in ctg_desc:
                        ctg_strategy = ctg_desc['values']
                    else:
                        raise KeyError('No strategy is defined for category "%s" of "%s" (missing "values")' % (ctg_name, cls))
                    ctg_obj = ExCat.from_dict({ 'name': ctg_name, **ctg_desc })
                ctg_defs[cls][ctg_name] = ctg_obj
                cls_layout.append(cat(ctg_obj, ctg_strategy))
            data_layout[cls] = subdivide(cls, *cls_layout, dictObj=CatLayout())

    layout_arg = False
    if CATS_LAYOUT_ARG not in data_layout:
        if CATS_LAYOUT_ARG not in desc or desc[CATS_LAYOUT_ARG]:
            data_layout[CATS_LAYOUT_ARG] = cats(dictObj=CatLayout())
            layout_arg = True

    desc_arg = False
    parsed_defs = parseCats(ctg_defs)
    if CATS_DESC_ARG not in data_layout:
        if CATS_DESC_ARG not in desc or desc[CATS_DESC_ARG]:
            data_layout[CATS_DESC_ARG] = cats_desc(parsed_defs)
            desc_arg = True

    def decorator(func: Callable) -> Callable:
        if hasattr(func, CATS_EXAMPLE_ATTR):
            exmps: Sequence[Mapping[str, Any]] = \
                getattr(func, CATS_EXAMPLE_ATTR)
            for exmp in exmps:
                exmp_layout = CatLayout()
                exmp_values = {}
                for cls in exmp:
                    val = exmp[cls]
                    if cls in ctg_defs:
                        ctg = ctg_defs[cls]
                        if not isinstance(val, tuple):
                            raise ValueError(f'According to the category descriptor, "{cls}" is a subdivided value. Please, specify an explicit category name using a (<value>, <category name>) tuple.')
                        if len(val) != 2:
                            raise ValueError(f'The tuple for "{cls}" is not a valid value-catrgory tuple.')
                        if val[1] not in ctg:
                            raise ValueError(f'The specified category "{val[1]} is not defined for value "{cls}".')
                        exmp_values[cls] = val[0]
                        exmp_layout[cls] = val[1]
                    else:
                        exmp_values[cls] = val

                exmp_args = { **exmp_values }
                if layout_arg:
                    exmp_args = { **exmp_args,
                                  CATS_LAYOUT_ARG: exmp_layout }
                if desc_arg:
                    exmp_args = { **exmp_args,
                                  CATS_DESC_ARG: parsed_defs }

                func = example(**exmp_args)(func)

        return given(**data_layout)(func)

    return decorator

def cat_example(*args: Any, **kwargs: Any) -> Callable[[Callable], Callable]:
    """
    Allows to specify categorized examples using value-category tuples:

    .. code-block:: python

       @given_divided(...)
       @cat_example(name=('user', 'non-empty'), role=('', 'empty'),
                    age=(-1, 'non-positive'))
       @cat_example(name=('user2', 'non-empty'),
                    role=('admin', 'non-empty'),
                    age=(20, 'positive'))
       def test(...):
           ...

    This decorator should be used with :func:`given_divided` or it will
    not work.

    The value-category tuples are required for categorized values, i.e.
    the values, given subdivided using :func:`given_divided`. On the
    contrary, the example values for uncategorized classes of values
    should be specified without additional tuple wrapping.
    """
    if args:
        raise ValueError("Can't use positional arguments in a categorized example.")

    def decorator(func: Callable) -> Callable:
        if hasattr(func, CATS_EXAMPLE_ATTR):
            setattr(func, CATS_EXAMPLE_ATTR,
                    getattr(func, CATS_EXAMPLE_ATTR) + [kwargs])
        else:
            setattr(func, CATS_EXAMPLE_ATTR, [kwargs])

        return func

    return decorator

def with_cat_checker(as_name: Optional[str] = None) -> Callable[[Callable], Callable]:
    """
    Wraps the given test function in :class:`.cat_checks.CatChecker`
    context using ``with CatChecker(_layout_, _desc_):``.

    :param as_name: An optional name under which the instantiated
        :class:`.cat_checks.CatChecker` should be passed to the
        wrapped function.

    :return: The decorator for the test function that wraps it
        with the category checker context.
    """

    def decor(func: Callable) -> Callable:
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            test_kwargs = { **kwargs }
    
            _layout_ = None
            if CATS_LAYOUT_ARG in test_kwargs:
                _layout_ = test_kwargs[CATS_LAYOUT_ARG]
                del test_kwargs[CATS_LAYOUT_ARG]
    
            if not _layout_:
                raise ValueError(f'Expected the category layout to be passed under "{CATS_LAYOUT_ARG}" name')
    
            _desc_ = None
            if CATS_DESC_ARG in test_kwargs:
                _desc_ = test_kwargs[CATS_DESC_ARG]
                del test_kwargs[CATS_DESC_ARG]
    
            with CatChecker(_layout_, _desc_) as ck:
                if as_name:
                    test_kwargs[as_name] = ck
                return func(*args, **test_kwargs)
    
        return wrapper

    return decor
