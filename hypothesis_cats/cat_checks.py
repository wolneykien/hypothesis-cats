# This file is a part of the Hypothesis-Cats Python package.
#
# Copyright (C) 2022  Paul Wolneykien <manowar@altlinux.org>
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301, USA.

"""
Hypothesis-Cats allows you to classify values generated by a
Hypothesis strategy. This module defines stuff for making assertions
based on categories of the given set of values.
"""

from typing import Any, Optional, Union, Sequence, TypedDict, \
    Callable, List, Pattern
from collections.abc import Iterable
import re

from .cat_desc import Cat
from .cat_strategies import cats

class GuardedRaisesDict(TypedDict):
    err: type[Exception]
    pattern: Union[str, Pattern]
    requires: dict[str, str]

class GuardedRaises():
    """
    """

    def __init__(self, err: type[Exception],
                 pattern: Union[None, str, Pattern] = None,
                 requires: Union[None, dict[str, str]] = None):
        """
        """
        self.err = err
        if pattern:
            self.pattern = re.compile(pattern)
        self.requires = requires

    def isExpected(self, cts: dict[str, Any],
                   ex: Union[None, Exception] = None) -> bool:
        """
        """
        if ex:
            if isinstance(ex, self.err):
                if self.pattern:
                    if self.pattern.match(str(ex)):
                        return self.checkReqs(cts)
            return False
        else:
            return self.checkReqs(cts)

    def checkReqs(self, cts: dict[str, Any]) -> bool:
        if self.requires:
            for r in self.requires:
                if self.requires[r]:
                    if r not in cts:
                        return False
                    else:
                        if isinstance(cts[r], Cat):
                            if self.requires[r] != cts[r].name:
                                return False
                        elif self.requires[r] != str(cts[r]):
                            return False

        return True

    def __repr__(self) -> str:
        """
        """
        estr = self.err.__name__

        if self.pattern:
            estr = estr + "('" + self.pattern.pattern + "')"

        return estr

class ExCat(Cat):
    """
    A category descriptor with exception expectations.
    """

    def __init__(self, name: str = None,
                 comment: Optional[str] = None,
                 raises: Union[
                     None,
                     type[Exception], GuardedRaises,
                     GuardedRaisesDict,
                     Sequence[
                         Union[
                             type[Exception], GuardedRaises,
                             GuardedRaisesDict
                         ]
                     ]
                 ] = None):
        """
        """
        super().__init__(name, comment)

        self.raises: List[GuardedRaises] = []
        if raises:
            if isinstance(raises, Sequence):
                for r in raises:
                    self.appendRaises(r)
            else:
                self.appendRaises(raises)

    def appendRaises(self,
                     raises: Union[
                         type[Exception], GuardedRaises,
                         GuardedRaisesDict
                     ]):
        """
        """
        if isinstance(raises, type) and \
               issubclass(raises, Exception):
            self.raises.append(GuardedRaises(raises, None))
        elif isinstance(raises, dict):
            self.raises.append(GuardedRaises(**raises))
        elif isinstance(raises, GuardedRaises):
            self.raises.append(raises)
        else:
            raise TypeError('appendRaises(r) expects an exception type or a GuardedRaises optionallly represented by a plain dictionary.')

    def isExpected(self, ex: Exception, cts: dict[str, Any]) -> bool:
        """
        """
        for r in self.raises:
            if r.isExpected(cts, ex):
                return True

        return False

    def expectedRaises(self, cts: dict[str, Any]) -> List[GuardedRaises]:
        """
        """
        expected: List[GuardedRaises] = []
        for r in self.raises:
            if r.isExpected(cts):
                expected.append(r)

        return expected

class ExCats():
    """
    """

    def __init__(self, cts: dict[str, Any] = cats().example()):
        """
        """
        self.cts = cts

    def __enter__(self) -> dict[str, Any]:
        """
        """
        return self.cts

    def __exit__(self, exc_type, exc_value: Exception,
                 traceback) -> bool:
        """
        """
        if exc_value:
            for cls in self.cts:
                if isinstance(self.cts[cls], ExCat):
                    if self.cts[cls].isExpected(exc_value, self.cts):
                        return True
            return False
        else:
            expected = self.expectedRaises()
            if expected:
                raise AssertionError('One of the following exceptions was expected: %s' % expected)

        return False

    def expectedRaises(self) -> dict[str, List[GuardedRaises]]:
        """
        """
        expected: dict[str, List[GuardedRaises]] = {}
        for cls in self.cts:
            if isinstance(self.cts[cls], ExCat):
                expected[cls] = self.cts[cls].expectedRaises(self.cts)

        return expected
